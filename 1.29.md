# 1.29

### 1. 贪心思想

贪心算法又称为贪婪法，是用来寻找最优解问题的常用方法。与**动态规划**不同的是，贪心算法在求解问题时，总是选择对于当前子问题最好的选择。也就是贪心算法的本质是**每次只顾眼前利益，并且到最后能获得最大利益**。

“贪婪”就像是一个贪心的人，每次都只能看到眼前（或局部）的利益最大化，走一步看一步，并且最后能够得到问题（全局）利益的最大化。
对于贪心算法，最重要的就是找到**每次的局部最优解**，而动态规划的关键在于找到**状态转移方程**。

### 2. 贪心法解题步骤

**步骤一**：从一个初始值开始计算
**步骤二**：采用迭代的过程，如果能够向目标问题前进一步，就根据局部最优策略，得到一部分的解
**步骤三**：将所有的解综合起来，得到最终的解

### 3. 典型题目分析

#### 3.1 剪绳子

> 题目来源：《剑指offer》面试题14：剪绳子
> 链接：https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof

**题目描述**：给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 `k[0],k[1]...k[m]` 。请问 `k[0]*k[1]*...*k[m]` 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

**算法分析**：将问题分为三种情况，一种是长度小于等于3时，长度为2只能剪成成都为1的两段；当绳子长度为3时，可能把绳子分成1和2的两段或者都为1的三段。一种是长度等于4时，把绳子剪成两段长度为2的绳子。最后一种情况是长度大于等于5时，我们尽量将绳子分为长度为3的绳子。
在 n > = 5 n>=5*n*>=5 时，可以证明 2 ( n − 2 ) > n 2(n-2)>n2(*n*−2)>*n* 并且 3 ( n − 3 ) > n 3(n-3)>n3(*n*−3)>*n*。即当绳子长度大于等于5时，我们把它剪成长度为3或者2的绳子段，此时 3 ( n − 3 ) > = 2 ( n − 2 ) 3(n-3)>=2(n-2)3(*n*−3)>=2(*n*−2)，所以我们应尽可能的剪成长度为3的绳子段。

```cpp
class Solution {
public:
    int cuttingRope(int n) {
        /* 当绳子长度小于等于3 */
        if (n < 2)
            return 0;
        if (n == 2)
            return 1;
        if (n == 3)
            return 2;
        long times_3 = n / 3;
        /* 当绳子最后剩下的长度为4的时候，就不能在减去长度为3的绳子
         * 因为有剪成2*2更大
         */
        long ans = 1;
        while (n > 4) {
            ans = ans * 3 % 1000000007;
            n -= 3;
        }
        return (int)(ans * n % 1000000007);
    }
};
```

#### 3.2 不同字符的最小序列

> 题目来源：力扣 1081 题
> 链接：https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters/

**题目描述**：返回字符串 text 中按字典序排列最小的子序列，该子序列包含 text 中所有不同字符一次。

```
示例 1：
输入："cdadabcc"
输出："adbc"
123
```

**基本概念**：
字典序 — 对于字符而言，按 ascii 码值进行比较，小的排在前，大的排在后。对于字符串，从第 0 位字符开始比较，ascii 码数值小的排在前面，如果相同，就延后一位比较 ascii 码值大小。
子序列：子序列不同于子串，子串要求它们在原串中连续，而子序列则不要求连续。子序列是原序列通过删除若干个字符的到的，例如acd是abcd的子序列，但不是子串。

**算法分析**：
首先判断能否使用贪心法
判断一个题目能否使用贪心法，最重要的是能否**通过局部最优解得到全局最优解**。题目求解的是字符串按字典排序最小的子序列，而且子序列重的字符只能出现一次。
因此我们只要保证所求的子序列从0位开始的每一个字符都是 ASCII 码值最小的字符，那整个子序列的字典序就是最小的。其中局部最优就是要子序列每一位的 ASCII 码值是最小的，根据局部最优解就能得到全剧最优解。

求解局部最优解，即如何保证子序列从第0位开始 ASCII 码值是最小的。
用示例1作为参考来求解局部最优解。例如`text = "cdadabcc"`，通过遍历字母表 `a~z`，从头到尾依次判断能否放入子序列中。
首先遍历到字母 `a`，我们发现字母 `a`第一次出现在 text 中的2号位置。然后判断字母 `a`之后的字符能否包括题目要求的全部字符，发现后面的字符有 `d`、`b`、`c` 包括了字符串的全部字符，因此字母 `a`可以作为子序列的第一个字符。
按照这个思路，我们再填充子序列的下一个位置。字母 `a` 已经在子序列中，遍历到字母 `b` 在 text 中，但是字母 `b` 之后的字符串不包含字母 `d`，因此字母 `b` 不能填充，依次我们发现字母 `d`可以作为子序列的第二个位置填充。
按照这一思路我们依次遍历完 text 的到最终的结果。

```cpp
class Solution {
public:
    string smallestSubsequence(string text) {
        string ret = "";
        int len = text.length();
        int all = 0;
        for (int i = 0; i < len; i++) {
            all |= (1 << (text[i] - 'a'));
        }
        //pos表示所选的当前字符在text中的位置
        int pos = 0;
        while (all) {
            for (int i = 0; i < 26; i++) {
                if ((all & (1 << i)) && isOk(text, all, i+'a', pos)) {
                    ret.push_back(i+'a');
                    all ^= (1 << i);
                    break;
                }
            }
        }
        return ret;
    }

    bool isOk(string& text, int all, char ch, int& pos) {
        int len = text.length();
        int i = pos;
        for (; i < len; i++) {
            if (text[i] == ch) {
                break;
            }
        }
        int p = i+1;
        int t = 0;
        for (; i < len; i++) {
            if (all & (1 << (text[i]-'a'))) {
                t |= (1 << (text[i]-'a'));
            }
        }
        if (t == all) {
            pos = p;
            return true;
        }
        return false;
    }
};
```