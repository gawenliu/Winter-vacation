# 1.28 链表

## 1.定义：

链表是一种动态数据结构，其需要对指针进行操作 。且链表这种数据结构很灵活，当插入一个节点时，只需要为新节点分配内存，然后调整指针的指向来确保新节点被链接到链表中。内存分配不是在创建链表时一次性完成的，而是每添加一个节点分配一次内存。

## 2.链表的优缺点：

优点：链表实现数据元素储存的顺序储存，是连续的。
缺点：因为含有大量的指针域，所以占用空间大，同时因为只有头结点（后面说明）是明确知道地址的，所以查找链表中的元素需要从头开始寻找，非常麻烦。

## 3.单向链表的节点定义:

```c++
struct ListNode
{
    int      m_nValue;
    ListNode*m_pNext;
};
```

## 4.往链表的末尾添加一个节点

```C++
void AddToTail(ListNode**pHead, int value)
{
    ListNode*pNew = new ListNode();
    pNew->m_nValue = value;
    pNew->m_pNext = nullptr;
    
    if(*pHead==nullptr)
    {
        *pHead=pNew;
    }
    else
    {
        ListNode*pNode = *pHead;
        while(pNode->m_pNext!=nullptr)
            pNode = pNode->m_pNext;
            
        pNode->m_pNext;
    }
}
```

## 5.在链表中找到第一个含有某值的节点并删除该节点

```C++
void RemoveNode(ListNode**pHead,int value)
{
   if(pHead==nullptr||*pHead==nullptr)
       return;
    ListNode*pToBeDeleted = nullptr;
    if((*pHead)->m_nValue==value)
    {
         pToBeDeleted = *pHead;
         *pHead = (*pHead)->m_pNext;
    }
    else
    {
        ListNode*pNode = *pHead;
        while(pNode->m_pNext!=nullptr
              &&pNode->m_pNext->m_nValue!=value)
              pNode = pNode->m_pNext;
        if(pNode->m_pNext!=nullptr&&pNode->m_pNext->m_nValue == value)
        {
            pToBeDeleted = pNode->m_pNext;
            pNode->m_pNext = pNode->m_pNext->m_pNext;
        }
    }
    if(pToBeDeleted!=nullptr)
    {
        delete pToBeDeleted;
        pToBeDeleted = nullptr;
    }
}
```

